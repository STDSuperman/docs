---
title: 核心概念
date: 2020-12-19 20:46:12
permalink: /pages/e8077b/
categories:
  - technology
  - RxJS
tags:
  - 
---
- Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。
- Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。
- Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。
- Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。
- Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。
- Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。

### Observable

表示一个概念，这个概念是一个可调用的未来值或事件的集合。它能被多个`observer`订阅，每个订阅关系相互独立、互不影响。

[![Observable图](https://s3.ax1x.com/2020/12/19/rUmGUx.png)](https://imgchr.com/i/rUmGUx)

举个栗子：

假设你订阅了一个博客或者是推送文章的服务号（微信公众号之类的），之后只要公众号更新了新的内容，那么该公众号就会把新的文章推送给你，在这段关系中，这个公众号就是一个`Observable`，用来产生数据的数据源。

相信看完上面的描述，你应该对`Observable`是个什么东西有了一定的了解了，那么这就好办了，下面我们来看看在`RxJS`中如何创建一个`Observable`。

```js
const myObservable = Rx.Observable.create(observer => {
  observer.next('foo');
  setTimeout(() => observer.next('bar'), 1000);
});
```

我们可以调用`Observable.create`方法来创建一个`Observable`，这个方法接受一个函数作为参数，这个函数叫做 `producer` 函数， 用来生成 `Observable` 的值。这个函数的入参是 `observer`，在函数内部通过调用 `observer.next()` 便可生成有一系列值的一个 `Observable`。

> 我们先不应理会`observer`是个什么东西，从创建一个`Observable`的方式来看，其实也就是调用一个`API`的事，十分简单，这样一个简单的`Observable`对象就创建出来了。



### Observer

一个回调函数的集合，它知道如何去监听由`Observable`提供的值。`Observer`在信号流中是一个观察者（哨兵）的角色，它负责观察任务执行的状态并向流中发射信号。

[![Observer](https://s3.ax1x.com/2020/12/19/rUu3h6.png)](https://imgchr.com/i/rUu3h6)

来让我们看看他长啥样：

```js
const observer = {
	next: function(value) {
		console.log(value);
	},
	error: function(error) {
		console.log(error)
	},
	complete: function() {
		console.log('complete')
	}
}
```

在`RxJS`中，`Observer`是可选的。在`next`、`error` 和 `complete`处理逻辑部分缺失的情况下，`Observable`仍然能正常运行，为包含的特定通知类型的处理逻辑会被自动忽略。

比如我们可以这样定义：

```js
const observer = {
	next: function(value) {
		console.log(value);
	},
	error: function(error) {
		console.log(error)
	}
}
```

它依旧是可以正常的运行。

那么它又是怎么来配合我们在实际战斗中使用的呢：

```js
const myObservable = Rx.Observable.create((observer) => {
    observer.next('111')
    setTimeout(() => {
        observer.next('777')
    }, 3000)
})

myObservable.subscribe((text) => console.log(text));
```
这里直接使用`subscribe`方法让一个`observer`订阅一个`Observable`，我们可以看看这个`subscribe`的函数定义来看看怎么实现订阅的：

```ts
subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;
```

源码是用`ts`写的，代码即文档，十分清晰，这里笔者给大家解读一下，我们从入参来看，从左至右依次是`next`、`error`，`complete`，且是可选的，我们可以自己选择性的传入相关回调，从这里也就印证了我们上面所说`next`、`error` 和 `complete`处理逻辑部分缺失的情况下仍可以正常运行，因为他们都是可选的。

### Subscription

`Subscription`就是表示`Observable`的执行，可以被清理。这个对象最常用的方法就是`unsubscribe`方法，它不需要任何参数，只是用来清理由`Subscription`占用的资源。同时，它还有`add`方法可以使我们取消多个订阅。

```js
const myObservable = Rx.Observable.create(observer => {
  observer.next('foo');
  setTimeout(() => observer.next('bar'), 1000);
});
const subscription = myObservable.subscribe(x => console.log(x));
// 稍后：
// 这会取消正在进行中的 Observable 执行
// Observable 执行是通过使用观察者调用 subscribe 方法启动的
subscription.unsubscribe();
```