---
title: 介绍
date: 2021-01-17 15:27:37
permalink: /pages/7ab3d3/
categories:
  - Vue
  - Vue服务端渲染
tags:
  - 
---

# 深入理解Vue SSR服务端渲染的“爱恨情仇”

## 概念

在进入本文进行详细分析之前，我们需要理解以下几个概念：
- `CSR` - 客户端渲染
- `Prerender` - 预渲染
- `SSR` - 服务端渲染

> 渲染：将数据和模版组装成`html`

### CSR-客户端渲染
顾名思义，客户端渲染即是由浏览器来负责全部的渲染工作，采用`ajax`进行异步数据的获取。对于我们传统的`SPA`（单页应用）来说，我们如果不去进行一些额外的工作，那么它默认就是采用客户端渲染。

也就是说服务端仅提供接口和静态资源，对于客户端渲染的应用来说，在用户初次访问网页的时候，会经历以下过程：

[![CSR](https://s3.ax1x.com/2021/01/20/sRDjmt.png)](https://imgchr.com/i/sRDjmt)

刚开始渲染的页面内容是空的，它需要执行`JS`文件来进行页面的元素的创建和插入，并进行重新渲染，如果说该`JS`文件过大，在请求该文件的过程中，我们看的页面就是空白的，所以对于`SPA`应用来说，我们经常需要面临的问题就是，如何减少首页白屏时间，这也就牵扯到我们各种前端性能优化相关的内容了。

#### 客户端渲染的优缺点
正所谓有利必有弊，福祸相依，那么对于客户端渲染来说，它又有哪些优缺点呢。这里将有笔者为你娓娓道来。

##### 优点
- 首次加载完之后，页面响应速度快。
- 前后端分离。
- 可以进行各种组件服用以及懒加载等能力。
- 结构清晰，无需与服务端各项逻辑进行耦合，开发体验友好。
- 前端技术栈可以更加丰富，无需被各种模板引擎所束缚。

##### 缺点
- 不利于`SEO`。
- 首页性能差，容易白屏。

针对于客户端渲染的这些问题来说，我们可以预见性的发现它更适合公司内部的管理后台或者其他不需要考虑`SEO`和首屏加载速度的场景下。

当然为了解决以上两大让人头疼的问题，我们就有了以下的方案：预渲染和服务端渲染。

### Prerender-预渲染

即利用打包工具对应用进行预先渲染，让用户在首次获取到`HTML`文件的时候就已经能看到我们的内容，接着等待`Bundle`下载解析完成之后再进行接管。

那么我们在打包构建预渲染的核心原理又是什么呢？其实这里就要用到我们十分强大的无头浏览器来帮助实现这项功能了，他会在本地启动一个无头浏览器，并访问我们配置好的路由，接着将渲染好的页面`HTML`内容输出到我们的`HTML`文件中，并建立相关的目录，也就是我们上述所看到的结构。

我们一般常用的无头例如有：`phantomjs`，`puppeteer`，对于`prerender-spa-plugin`插件来说，他内部就是采用了`phantomjs`作为无头浏览器进行预渲染。

[![pre-render](https://s3.ax1x.com/2021/01/20/sRDgSJ.png)](https://imgchr.com/i/sRDgSJ)

#### 优缺点

##### 优点

- `SEO` - 对于搜索引擎爬虫来说（先排除高级爬虫），它不会等待你的`JS`执行完成之后才进行抓取，如果不进行预渲染，对于客户端渲染应用来说，`HTML`文件中几乎没有什么内容，故会影响你的搜索排名。采用预渲染就能保证在首次加载就能获取到相关的`HTML`内容，利于`SEO`。
- 弱网环境：对于网络条件较差的用户来说，你的`Bundle`文件过大，会导致页面长时间白屏，这将使你白白流失很多用户，所以首次内容的快速呈现也是十分重要的，解决首页白屏问题。
- 兼容浏览器差异：对于部分浏览器（点谁心里有数啊QAQ）来说，有些高级特性是不支持的，这个时候如果在执行`JS`的过程中异常将可能存在浏览器页面显示异常的情况，这个时候预渲染的能力也是能兼容这种情况的。

那么我们又该如何进行预渲染呢？

这里就直接以`Webpack`为例，我们可以直接使用它的预渲染插件：`prerender-spa-plugin`。

我们直接使用该插件的时候可以配置需要预渲染的路由：

> 默认情况下 `HTML` 会在脚本执行完被捕获并输出。你也可以指定一些钩子，`HTML` 将会在特定时机被捕获。

```js
var path = require('path')
var PrerenderSpaPlugin = require('prerender-spa-plugin')
{
  //...
  plugins: [
    new PrerenderSpaPlugin({
      path.resolve(__dirname, './dist'),
      ['/home', '/foo'],
      {
        // 监听到自定事件时捕获
        // document.dispatchEvent(new Event('custom-post-render-event'))
        captureAfterDocumentEvent: 'custom-post-render-event',

        // 查询到指定元素时捕获
        captureAfterElementExists: '#content',

        // 定时捕获
        captureAfterTime: 5000
      }
    })
  ]
}
```

这样配置完之后我们就能在我们的`dist`目录中找到相关路由的预渲染`HTML`文件啦。

```powershell
dist
│  index.html
│
├─home
│  index.html
│
├─foo
│  index.html

```

从宏观角度上看，是不是也是十分便捷呢，这样我们一些需要进行预先渲染的页面就能具备预渲染能力了。

##### 缺点
也正是因为预渲染的构建是由打包工具在打包的时候就渲染出来了，所以如果不重新构建，那么用户所看到的预渲染页面永远都是一成不变的，即便你的页面数据早已更新，但是初次渲染的时候，浏览器展示的依旧是这套老旧的数据，如果想要看到最新的数据就需要等待`JS`下载完毕重新渲染的时候才能出现，从而是用户感觉很突兀的感觉。

由于需要借助打包工具的力量，所以我们需要增加一些配置成本，不仅如此，在进行预渲染时，也同样会拉长打包的总时间，使我们每次构建的速度大大降低，这是十分糟糕的开发体验。

### SSR-服务端渲染
服务端渲染的方式其实就好比我们以前使用`jsp`等技术直接在服务端借助模板引擎直接渲染出`HTML`文档返回给客户端，对于一些小型项目而言，这种方式无疑是比较节约人力成本的，但不得不说这种开发方式十分不友好。

不同于预渲染方式，服务端渲染的好处在于，客户端在初次获取到页面时看到的就已经是最新的数据渲染出来的页面了，服务端会预先获取到需要渲染的数据，并组装成完整的页面返回给客户端，这种方式无疑就比预渲染数据延迟的模式友好得多。

对于我们目前主流的前端框架来说：`Vue`、`React`，都已支持了服务端渲染，只不过相对于纯`SPA`页面开发来说，研发成本也相应的有所提高，我们需要考虑许多兼容情况。如果使用过这两大框架的童鞋可能就会接触到虚拟`DOM`这个概念，在实现上，他们其实也就是一个个`JS`对象，我们在前端一般操作`DOM`的方式都是在操作虚拟`DOM`，也正是因为有虚拟`DOM`，我们才能方便的实现`SSR`。

我们在浏览器端操作虚拟`DOM`对应的是操作真实的`DOM`元素，而在进行服务端渲染时，`Node`端操作虚拟`DOM`实际上是在操作字符串。

## 参考文档

[后端渲染、客户端渲染(CSR)、同构应用(SSR)](https://github.com/amandakelake/blog/issues/60)
[单页应用多路由预渲染指南](https://beyoursun.github.io/2017/10/13/Spa-Prerender-Guide/)