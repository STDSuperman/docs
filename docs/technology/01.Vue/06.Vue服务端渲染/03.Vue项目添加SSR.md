---
title: Vue项目添加SSR
date: 2021-01-24 15:12:53
permalink: /pages/947faa/
categories:
  - Vue
  - Vue服务端渲染
tags:
  - 
---
前面我们介绍完怎么将一个简单的`Vue`实例进行渲染给客户端之后，接下来我们要继续深入了，毕竟我们实际项目中，应该不存在单纯这么简单的业务代码吧。

### 涉及技术栈
- `node.js`
- `Vue`
- `express`
- `webpack`

### 准备工作

在正式开始介绍如何配合现有`Vue`项目实现`SSR`之前，我们先初始化一个简易的`Vue`项目。你可以使用`Vue-cli`创建一个简易项目，也可以跟着笔者直接自己借鉴官方项目结构创建一个简单的项目。

当然也可直接`clone`笔者的演示项目（建议）：[项目地址](https://github.com/STDSuperman/VueSSR-Lesson)

#### 项目目录

首先新建一个文件夹，作为我们整个项目的根目录，接着在命令行中输入`npm init -y`，初始化`npm`，然后按照按照如下目录结构创建对应的文件，创建时我们先不用关心各个文件中内容是什么，后面将分逐一进行讲解。

```powershell
├─.babelrc
├─entry-client.js
├─entry-server.js
├─index.html
├─package.json
├─server.js
├─src
|  ├─app.js
|  ├─App.vue
|  ├─store
|  |   ├─actions.js
|  |   ├─index.js
|  |   └mutations.js
|  ├─router
|  |   └index.js
|  ├─components
|  |     ├─Foo.vue
|  |     └Home.vue
├─build
|   ├─webpack.base.config.js
|   ├─webpack.client.config.js
|   └webpack.server.config.js
```

### webpack配置

如果想要对一个完整的`Vue`项目添加`SSR`，我们需要先对它进行打包，然后将结果作为我们服务器提供`SSR`服务的依赖文件。

我们可以注意到，在上述的文件目录中，有一个`build`，目录，它就是用来放置我们的`webpack`相关配置的。这里我们可以再回过头回想一下前面放出来的官方`SSR`整体的流程图，我们可以清晰的知道，我们在在配置`webpack`客户端与服务端相关配置文件时，同时也需要创建对应的入口文件，也就上上述目录中的`entry-client.js`与`entry-server.js`。

#### webpack.base.config.js
对于我们整个项目来说，服务端`webpack`配置与客户端`webpack`配置也会存在一些公共配置，所以我们可以将共有部分抽出来，作为基础配置，最后合并到特定端的配置中。

来看看都有啥：

```js

const VueLoaderPlugin = require('vue-loader/lib/plugin');
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const webpack = require('webpack')

module.exports = {
    mode: 'development',
    module: {
        rules: [
            { test: /\.js$/, loader: 'babel-loader' },
            { test: /\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] },
            { test: /\.scss$/, loader: 'sass-loader' },
            { test: /\.vue$/, loader: 'vue-loader' },
        ]
    },
    output: {
        path: path.resolve(__dirname, '../dist')
    },
    plugins: [
        new VueLoaderPlugin(),
        new MiniCssExtractPlugin({
            filename: 'css/[name].[contenthash:8].css'
        }),
        new webpack.NoEmitOnErrorsPlugin()
    ],
    stats: {
        logging: 'none'
    },
    resolve: {
        extensions: ['.vue', '.ts', '.js'],
        alias: {
            '@': path.resolve(__dirname, '../src')
        }
    }
}
```

> 这里对每个参数的含义就不进行过多介绍了，对于`webpack`配置项不太了解的可以参考相关中文文档。传送门：[webpack中文网](https://www.webpackjs.com/concepts/)

##### loader

这里主要用到了几个`loader`，分别是：

- `babel-loader`：用来转换高级语法为低级语法，这里相关的配置笔者就将它写到`.babelrc`文件中了，参见上述目录结构。
  - 具体内容如下：
    - ```json
        {
            "presets": ["@babel/preset-env"],
            "plugins": ["@babel/plugin-syntax-dynamic-import"]
        }
        ```
- `MiniCssExtractPlugin.loader`与`css-loader`：处理`css`相关内容（具体用法见官方文档）。
- `sass-loader`：笔者在项目中比较喜欢使用`scss`，所以这里添加了对`scss`的处理。
- `vue-loader`：对于`Vue`项目来说，这个`loader`应该还是很重要的吧，用来处理`.vue`文件。

##### plugins

- `VueLoaderPlugin`：必须的插件， 它的职责是将你定义过的其它规则复制并应用到 `.vue` 文件里相应语言的块。例如，如果你有一条匹配 `/\.js$/` 的规则，那么它会应用到 .vue 文件里的 `<script>` 块。
- `MiniCssExtractPlugin`：将 `CSS` 提取到单独的文件中，为每个包含 `CSS` 的 `JS` 文件创建一个 `CSS` 文件，并且支持 `CSS` 和 `SourceMaps` 的按需加载。
- `NoEmitOnErrorsPlugin`：在编译出现错误时，使用 `NoEmitOnErrorsPlugin` 来跳过输出阶段。

##### 安装相关依赖

笔者比较喜爱使用`yarn`进行包安装，你也可以采用`npm`或`cnpm`，只需要将下面的`yarn add `改成`npm i`即可。

```shell
yarn add vue-loader babel-loader mini-css-extract-plugin webpack@4 webpack-cli sass-loader @babel/preset-env @babel/plugin-syntax-dynamic-import vue-template-compiler css-loader -D
```

> 这里还是建议搭建直接克隆笔者的项目比较方便，万一依赖项笔者漏写了，估计你们要锤死我。

#### webpack.client.config.js

客户端构建相关配置项：

```js
const VueSSRClientPlugin = require('vue-server-renderer/client-plugin');
const webpackMerge = require('webpack-merge');
const baseConfig = require('./webpack.base.config');
const path = require('path')
const TerserPlugin = require("terser-webpack-plugin");
const webpack = require('webpack')

const hotModuleScript = 'webpack-hot-middleware/client?path=/__webpack_hmr&timeout=10000&reload=true'

module.exports = webpackMerge.merge(baseConfig, {
    entry: [hotModuleScript, path.resolve(__dirname, '../entry-client.js')],
    optimization: {
        splitChunks: {
            cacheGroups: {
                common: {
                    minChunks: 2,
                    priority: -10,
                    reuseExistingChunk: true
                }
            }
        },
        minimize: true,
        minimizer: [new TerserPlugin()]
    },
    plugins: [
        new VueSSRClientPlugin(),
        new webpack.HotModuleReplacementPlugin()
    ]
})
```

##### plugins
这里基于基础配置上，添加了热替换的插件和`Vue SSR`客户端构建插件，上面`entry`部分的写法是为了给我们的项目添加热更新能力，这里主要需要配合`webpack-hot-middleware`进行实现，具体配置方式可以参考官方文档：[传送门](https://github.com/webpack-contrib/webpack-hot-middleware#readme)。

同时这里笔者也配置了一下代码分割，将公共代码进行抽离，并改用`terser-webpack-plugin`对代码进行压缩（`webpack5`之后内置的，这里采用`webpack4`作为演示）。

##### 安装依赖
在安装完基础配置文件的依赖后，客户端相关配置也需要进行依赖安装：

```shell
yarn add webpack-merge terser-webpack-plugin webpack-hot-middleware -D
```

#### webpack.server.config.js

同理，这里是服务端相关配置。

```js
const webpackMerge = require('webpack-merge');
const baseConfig = require('./webpack.base.config');
const path = require('path');
const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')
const nodeExternals = require('webpack-node-externals')

module.exports = webpackMerge.merge(baseConfig, {
    entry: path.resolve(__dirname, '../entry-server.js'),
    output: {
        path: path.resolve(__dirname, '../dist'),
        filename: 'server-bundle.js',
        libraryTarget: 'commonjs2'
    },
    target: 'node',
    externals: nodeExternals({
        allowlist: [/\.css$/]
    }),
    devtool: 'source-map',
    plugins: [new VueSSRServerPlugin()]
})
```

对于服务端相关配置来说，我们这里就不需要配置热更新相关了，所以这里只用到了一个官方提供用来构建服务端配置的插件`server-plugin`，然后我们这里配置了`externals`，对于服务端来说，它无法处理`css`相关逻辑，所以我们这里直接给他忽略一下。同时，这里还有一个注意点，我们需要把构建的目标改成`node`，也就是设置`target: 'node'`，不仅如此，这里还需要配置`libraryTarget: 'commonjs2'`，以便我们在`node`端进行导入。

##### 安装依赖

```shell
yarn add webpack-node-externals -D
```
这里就新增了一个依赖项。

好了，介绍完`webpack`配置相关之后，我们就可以分别构建出服务端需要的结果和客户端相关的结果了，离成功又近了一步。